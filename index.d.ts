/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export declare class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
export interface AdapterInfo {
  name: string
  vendor: number
  device: number
  deviceType: string
  backend: string
}
export interface AdapterLimits {
  maxTextureDimension1D: number
  maxTextureDimension2D: number
  maxTextureDimension3D: number
  maxBindGroups: number
  maxBufferSize: number
}
/** Texture descriptor */
export interface TextureDescriptor {
  label?: string
  width: number
  height: number
  depth?: number
  format: string
  usage: number
  dimension?: string
  mipLevelCount?: number
  sampleCount?: number
}
/** Buffer usage flags object */
export interface BufferUsage {
  copySrc: number
  copyDst: number
  storage: number
  uniform: number
  vertex: number
  index: number
  mapRead: number
  mapWrite: number
  indirect: number
  queryResolve: number
}
/** Get buffer usage constants */
export declare function bufferUsage(): BufferUsage
/** Map mode object */
export interface MapMode {
  read: number
  write: number
}
/** Get map mode constants */
export declare function mapMode(): MapMode
/** Texture usage flags object */
export interface TextureUsage {
  copySrc: number
  copyDst: number
  textureBinding: number
  storageBinding: number
  renderAttachment: number
}
/** Get texture usage constants */
export declare function textureUsage(): TextureUsage
/** Bind group entry for mixed resources */
export interface BindGroupEntry {
  binding: number
  resourceType: string
  bufferIndex?: number
  textureIndex?: number
  samplerIndex?: number
}
/** Compute pass descriptor (simplified) */
export interface ComputePassDescriptor {
  label?: string
}
/** Render pass descriptor */
export interface RenderPassDescriptor {
  label?: string
  colorAttachments: Array<RenderPassColorAttachment>
  depthStencilAttachment?: RenderPassDepthStencilAttachment
}
export interface RenderPassColorAttachment {
  view: ExternalObject<GpuTextureView>
  resolveTarget?: ExternalObject<GpuTextureView>
  clearValue?: Color
  loadOp: string
  storeOp: string
}
export interface Color {
  r: number
  g: number
  b: number
  a: number
}
export interface RenderPassDepthStencilAttachment {
  view: ExternalObject<GpuTextureView>
  depthClearValue?: number
  depthLoadOp?: string
  depthStoreOp?: string
  stencilClearValue?: number
  stencilLoadOp?: string
  stencilStoreOp?: string
}
/** Sampler descriptor */
export interface SamplerDescriptor {
  label?: string
  addressModeU?: string
  addressModeV?: string
  addressModeW?: string
  magFilter?: string
  minFilter?: string
  mipmapFilter?: string
  lodMinClamp?: number
  lodMaxClamp?: number
  compare?: string
  maxAnisotropy?: number
}
/** Buffer descriptor following WebGPU spec */
export interface BufferDescriptor {
  label?: string
  size: number
  usage: number
  mappedAtCreation?: boolean
}
/** Shader module descriptor following WebGPU spec */
export interface ShaderModuleDescriptor {
  label?: string
  code: string
}
/** Pipeline layout descriptor following WebGPU spec */
export interface PipelineLayoutDescriptor {
  label?: string
}
/** Compute pipeline descriptor following WebGPU spec */
export interface ComputePipelineDescriptor {
  label?: string
  compute: ComputeStage
}
export interface ComputeStage {
  entryPoint: string
}
/** Command encoder descriptor following WebGPU spec */
export interface CommandEncoderDescriptor {
  label?: string
}
/** Bind group descriptor following WebGPU spec */
export interface BindGroupDescriptor {
  label?: string
}
/** Bind group layout descriptor following WebGPU spec */
export interface BindGroupLayoutDescriptor {
  label?: string
  entries: Array<BindGroupLayoutEntry>
}
export interface BindGroupLayoutEntry {
  binding: number
  visibility: number
  buffer?: BufferBindingLayout
  sampler?: SamplerBindingLayout
  texture?: TextureBindingLayout
  storageTexture?: StorageTextureBindingLayout
}
export interface BufferBindingLayout {
  type?: string
  hasDynamicOffset?: boolean
  minBindingSize?: number
}
export interface SamplerBindingLayout {
  type?: string
}
export interface TextureBindingLayout {
  sampleType?: string
  viewDimension?: string
  multisampled?: boolean
}
export interface StorageTextureBindingLayout {
  access?: string
  format: string
  viewDimension?: string
}
/** Render pipeline descriptor following WebGPU spec */
export interface RenderPipelineDescriptor {
  label?: string
  vertex: VertexState
  primitive?: PrimitiveState
  depthStencil?: DepthStencilState
  multisample?: MultisampleState
  fragment?: FragmentState
}
export interface VertexState {
  entryPoint: string
  buffers?: Array<VertexBufferLayout>
}
export interface VertexBufferLayout {
  arrayStride: number
  stepMode?: string
  attributes: Array<VertexAttribute>
}
export interface VertexAttribute {
  format: string
  offset: number
  shaderLocation: number
}
export interface PrimitiveState {
  topology?: string
  stripIndexFormat?: string
  frontFace?: string
  cullMode?: string
}
export interface DepthStencilState {
  format: string
  depthWriteEnabled?: boolean
  depthCompare?: string
  stencilFront?: StencilFaceState
  stencilBack?: StencilFaceState
  stencilReadMask?: number
  stencilWriteMask?: number
  depthBias?: number
  depthBiasSlopeScale?: number
  depthBiasClamp?: number
}
export interface StencilFaceState {
  compare?: string
  failOp?: string
  depthFailOp?: string
  passOp?: string
}
export interface MultisampleState {
  count?: number
  mask?: number
  alphaToCoverageEnabled?: boolean
}
export interface FragmentState {
  entryPoint: string
  targets: Array<ColorTargetState>
}
export interface ColorTargetState {
  format: string
  blend?: BlendState
  writeMask?: number
}
export interface BlendState {
  color: BlendComponent
  alpha: BlendComponent
}
export interface BlendComponent {
  srcFactor: string
  dstFactor: string
  operation: string
}
/**
 * GPU instance - entry point for WebGPU API
 *
 * This is the starting point for all WebGPU operations. Create an instance to
 * enumerate and request GPU adapters.
 */
export declare class Gpu {
  /**
   * Create a new GPU instance
   *
   * Example:
   * ```js
   * const gpu = Gpu.create()
   * ```
   */
  static create(): Gpu
  /**
   * Request a GPU adapter
   *
   * Example:
   * ```js
   * const adapter = await gpu.requestAdapter()
   * ```
   */
  requestAdapter(powerPreference?: string | undefined | null): Promise<GpuAdapter>
  /**
   * Enumerate all available adapters
   *
   * Returns a list of all available GPU adapters with their backend (Metal, Vulkan, DX12).
   * Useful for debugging and displaying available hardware to users.
   */
  enumerateAdapters(): Array<string>
}
/**
 * GPU adapter - represents a physical GPU or software renderer
 *
 * Adapters provide information about GPU capabilities (features, limits)
 * and are used to request logical devices for GPU operations.
 */
export declare class GpuAdapter {
  /**
   * Get adapter information
   *
   * Returns name, vendor ID, device ID, type, and backend.
   */
  getInfo(): AdapterInfo
  /**
   * Get adapter features
   *
   * Returns a list of optional features supported by this adapter.
   * Features must be explicitly requested when creating a device.
   */
  getFeatures(): Array<string>
  /**
   * Get adapter limits
   *
   * Returns maximum resource sizes and counts supported by this adapter.
   */
  getLimits(): AdapterLimits
  /**
   * Request a device from this adapter
   *
   * Creates a logical device for executing GPU operations.
   * Currently requests timestamp query feature by default.
   */
  requestDevice(): Promise<GpuDevice>
}
export declare class GpuDevice {
  /** Create a GPU buffer */
  createBuffer(descriptor: BufferDescriptor): GpuBuffer
  /** Create a shader module */
  createShaderModule(descriptor: ShaderModuleDescriptor): GpuShaderModule
  /** Create a command encoder */
  createCommandEncoder(): GpuCommandEncoder
  /**
   * Submit commands to the queue
   * Note: This consumes the command buffer
   */
  queueSubmit(commandBuffer: GpuCommandBuffer): void
  /** Poll the device */
  poll(forceWait?: boolean | undefined | null): void
  /** Write data to a buffer using the queue */
  queueWriteBuffer(buffer: GpuBuffer, offset: number, data: Buffer): void
  /** Copy data from one buffer to another */
  copyBufferToBuffer(encoder: GpuCommandEncoder, source: GpuBuffer, sourceOffset: number, destination: GpuBuffer, destinationOffset: number, size: number): void
  /** Copy data from buffer to texture */
  copyBufferToTexture(encoder: GpuCommandEncoder, source: GpuBuffer, sourceOffset: number, bytesPerRow: number, rowsPerImage: number | undefined | null, destination: GpuTexture, mipLevel: number | undefined | null, originX: number | undefined | null, originY: number | undefined | null, originZ: number | undefined | null, width: number, height: number, depth?: number | undefined | null): void
  /** Copy data from texture to buffer */
  copyTextureToBuffer(encoder: GpuCommandEncoder, source: GpuTexture, mipLevel: number | undefined | null, originX: number | undefined | null, originY: number | undefined | null, originZ: number | undefined | null, destination: GpuBuffer, destinationOffset: number, bytesPerRow: number, rowsPerImage: number | undefined | null, width: number, height: number, depth?: number | undefined | null): void
  /** Create a texture */
  createTexture(descriptor: TextureDescriptor): GpuTexture
  /** Create a sampler */
  createSampler(descriptor: SamplerDescriptor): GpuSampler
  /**
   * Create a query set for timestamp or occlusion queries
   * query_type: "timestamp" or "occlusion"
   * count: number of queries in the set
   */
  createQuerySet(queryType: string, count: number): GpuQuerySet
  /** Create a bind group layout */
  createBindGroupLayout(descriptor: BindGroupLayoutDescriptor): GpuBindGroupLayout
  /**
   * Create a bind group with buffer bindings
   * Bindings are specified as: binding index, buffer, offset, size
   * All buffers are bound sequentially starting from binding 0
   */
  createBindGroupBuffers(label: string | undefined | null, layout: GpuBindGroupLayout, buffers: Array<GpuBuffer>): GpuBindGroup
  /** Create a bind group with mixed resources (buffers, textures, samplers) */
  createBindGroup(label: string | undefined | null, layout: GpuBindGroupLayout, entries: Array<BindGroupEntry>, buffers: Array<GpuBuffer>, textures: Array<GpuTextureView>, samplers: Array<GpuSampler>): GpuBindGroup
  /** Create a pipeline layout */
  createPipelineLayout(descriptor: PipelineLayoutDescriptor, bindGroupLayouts: Array<GpuBindGroupLayout>): GpuPipelineLayout
  /** Create a compute pipeline */
  createComputePipeline(label: string | undefined | null, layout: GpuPipelineLayout | undefined | null, shaderModule: GpuShaderModule, entryPoint: string): GpuComputePipeline
  /**
   * Create a render pipeline (simplified)
   * vertex_formats: array of format strings for vertex attributes
   * fragment_targets: array of format strings for color targets
   * depth_stencil_format: optional depth/stencil format (e.g., "depth24plus")
   * blend_mode: optional blend mode ("replace", "alpha", "additive", "premultiplied")
   * write_mask: optional color write mask (0-15, default 15 = all channels)
   * sample_count: optional MSAA sample count (1, 2, 4, 8, default 1)
   */
  createRenderPipeline(label: string | undefined | null, layout: GpuPipelineLayout | undefined | null, vertexShader: GpuShaderModule, vertexEntryPoint: string, vertexFormats: Array<string>, fragmentShader: GpuShaderModule | undefined | null, fragmentEntryPoint: string | undefined | null, fragmentFormats: Array<string>, depthStencilFormat?: string | undefined | null, blendMode?: string | undefined | null, writeMask?: number | undefined | null, sampleCount?: number | undefined | null): GpuRenderPipeline
  /**
   * Create a render bundle - reusable recorded render commands
   * This creates a bundle that can be executed multiple times in render passes
   */
  createRenderBundle(label: string, pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, vertexCount: number, bindGroups: Array<GpuBindGroup> | undefined | null, colorFormats: Array<string>): GpuRenderBundle
  /** Create an indexed render bundle */
  createRenderBundleIndexed(label: string, pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, indexBuffer: GpuBuffer, indexFormat: string, indexCount: number, bindGroups: Array<GpuBindGroup> | undefined | null, colorFormats: Array<string>): GpuRenderBundle
  /** Destroy the device */
  destroy(): void
}
export declare class GpuShaderModule { }
export declare class GpuCommandEncoder {
  /** Begin a compute pass and execute it with the given pipeline and bind groups */
  computePass(pipeline: GpuComputePipeline, bindGroups: Array<GpuBindGroup>, workgroupsX: number, workgroupsY?: number | undefined | null, workgroupsZ?: number | undefined | null): void
  /**
   * Execute a compute pass with indirect dispatch
   * The indirect buffer contains dispatch parameters (workgroups_x, workgroups_y, workgroups_z)
   */
  computePassIndirect(pipeline: GpuComputePipeline, bindGroups: Array<GpuBindGroup>, indirectBuffer: GpuBuffer, indirectOffset: number): void
  /**
   * Execute a render pass (simplified inline execution)
   * color_attachments: array of texture views to render to (MSAA textures if using MSAA)
   * clear_colors: optional array of [r, g, b, a] values for clearing
   * bind_groups: optional array of bind groups to set
   * depth_stencil_attachment: optional depth/stencil texture view
   * clear_depth: optional depth clear value (0.0 to 1.0)
   * resolve_targets: optional array of texture views to resolve MSAA to (must match color_attachments length)
   */
  renderPass(pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, vertexCount: number, colorAttachments: Array<GpuTextureView>, clearColors?: Array<Array<number>> | undefined | null, bindGroups?: Array<GpuBindGroup> | undefined | null, depthStencilAttachment?: GpuTextureView | undefined | null, clearDepth?: number | undefined | null, resolveTargets?: Array<GpuTextureView> | undefined | null): void
  /** Execute a render pass with indexed drawing */
  renderPassIndexed(pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, indexBuffer: GpuBuffer, indexFormat: string, indexCount: number, colorAttachments: Array<GpuTextureView>, clearColors?: Array<Array<number>> | undefined | null, bindGroups?: Array<GpuBindGroup> | undefined | null, depthStencilAttachment?: GpuTextureView | undefined | null, clearDepth?: number | undefined | null, resolveTargets?: Array<GpuTextureView> | undefined | null): void
  /**
   * Execute a render pass with indirect drawing
   * The indirect buffer contains draw parameters (vertex_count, instance_count, first_vertex, first_instance)
   */
  renderPassIndirect(pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, indirectBuffer: GpuBuffer, indirectOffset: number, colorAttachments: Array<GpuTextureView>, clearColors?: Array<Array<number>> | undefined | null, bindGroups?: Array<GpuBindGroup> | undefined | null, depthStencilAttachment?: GpuTextureView | undefined | null, clearDepth?: number | undefined | null, resolveTargets?: Array<GpuTextureView> | undefined | null): void
  /**
   * Execute a render pass with indexed indirect drawing
   * The indirect buffer contains draw parameters (index_count, instance_count, first_index, base_vertex, first_instance)
   */
  renderPassIndexedIndirect(pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, indexBuffer: GpuBuffer, indexFormat: string, indirectBuffer: GpuBuffer, indirectOffset: number, colorAttachments: Array<GpuTextureView>, clearColors?: Array<Array<number>> | undefined | null, bindGroups?: Array<GpuBindGroup> | undefined | null, depthStencilAttachment?: GpuTextureView | undefined | null, clearDepth?: number | undefined | null, resolveTargets?: Array<GpuTextureView> | undefined | null): void
  /**
   * Write a timestamp to a query set
   * query_set: the query set to write to
   * query_index: the index of the query to write (0 to count-1)
   */
  writeTimestamp(querySet: GpuQuerySet, queryIndex: number): void
  /**
   * Resolve query results to a buffer
   * query_set: the query set to resolve
   * first_query: the first query index to resolve
   * query_count: the number of queries to resolve
   * destination: the buffer to write results to
   * destination_offset: the byte offset in the destination buffer
   */
  resolveQuerySet(querySet: GpuQuerySet, firstQuery: number, queryCount: number, destination: GpuBuffer, destinationOffset: number): void
  /**
   * Execute render bundles in a render pass
   * This is more efficient than recording the same commands multiple times
   */
  renderPassBundles(bundles: Array<GpuRenderBundle>, colorAttachments: Array<GpuTextureView>, clearColors?: Array<Array<number>> | undefined | null): void
  /** Finish encoding and return a command buffer */
  finish(): GpuCommandBuffer
}
export declare class GpuCommandBuffer { }
/**
 * GPU buffer - contiguous memory allocation on the GPU
 *
 * Buffers store data for shaders (vertices, indices, uniforms, storage).
 * They can be written from CPU (via queueWriteBuffer) and read back (via mapRead).
 */
export declare class GpuBuffer {
  /** Get the size of the buffer */
  size(): number
  /** Get the usage flags of the buffer */
  usage(): number
  /**
   * Map the buffer asynchronously for reading or writing
   *
   * Asynchronously maps the buffer for CPU access.
   * mode: "READ" or "WRITE"
   * Buffer must have MAP_READ or MAP_WRITE usage flag.
   */
  mapAsync(mode: string): Promise<void>
  /**
   * Get the mapped range as a buffer
   *
   * Returns the mapped data as a Node.js Buffer.
   * Must be called after mapAsync() succeeds.
   * The buffer must remain mapped until unmap() is called.
   */
  getMappedRange(): Buffer
  /**
   * Unmap the buffer
   *
   * Releases the mapped memory. Must be called after mapRead before using buffer in GPU operations.
   */
  unmap(): void
  /** Write data to buffer using mapped memory */
  writeBuffer(data: Buffer): Promise<void>
  /**
   * Destroy the buffer
   *
   * Explicitly releases GPU resources. Buffers are automatically destroyed when dropped.
   */
  destroy(): void
}
/**
 * GPU texture - multi-dimensional image data on the GPU
 *
 * Textures store image data for rendering and compute operations.
 * Create views to bind textures to shaders.
 */
export declare class GpuTexture {
  /** Create a view of this texture */
  createView(label?: string | undefined | null): GpuTextureView
  /** Get texture width */
  width(): number
  /** Get texture height */
  height(): number
  /** Destroy the texture */
  destroy(): void
}
/**
 * Texture view - a view into a texture for binding to shaders
 *
 * Views define how shaders access texture data (format, mip levels, array layers).
 */
export declare class GpuTextureView { }
/**
 * Bind group layout - describes resource bindings for shaders
 *
 * Bind group layouts define the structure of bind groups: which binding indices
 * contain buffers, textures, or samplers, and their visibility (vertex/fragment/compute).
 */
export declare class GpuBindGroupLayout { }
/**
 * Bind group - collection of resources bound to shaders
 *
 * Bind groups connect GPU resources (buffers, textures, samplers) to shader binding points.
 * They're bound to pipelines during command encoding.
 */
export declare class GpuBindGroup { }
/**
 * Pipeline layout - defines bind group layouts for a pipeline
 *
 * Pipeline layouts specify the organization of bind groups (resources like buffers, textures)
 * that shaders can access during pipeline execution.
 */
export declare class GpuPipelineLayout { }
/**
 * Compute pipeline - configured compute shader program
 *
 * Compute pipelines execute compute shaders for general-purpose GPU computation.
 * They're created from a shader module, entry point, and pipeline layout.
 */
export declare class GpuComputePipeline { }
/**
 * Render pipeline - configured graphics pipeline
 *
 * Render pipelines define the complete graphics state: vertex/fragment shaders,
 * vertex layout, blend modes, depth/stencil, and MSAA configuration.
 */
export declare class GpuRenderPipeline { }
/**
 * GPU sampler - defines how textures are sampled in shaders
 *
 * Samplers control filtering (nearest/linear), address modes (repeat/clamp),
 * and LOD (level of detail) for texture sampling.
 */
export declare class GpuSampler { }
/**
 * GPU query set - for GPU performance measurement
 *
 * Query sets collect GPU timestamps for profiling render and compute passes.
 */
export declare class GpuQuerySet {
  /** Destroy the query set */
  destroy(): void
}
/**
 * Render bundle - pre-recorded render commands that can be reused
 *
 * Render bundles record draw commands once and execute them multiple times.
 * This reduces CPU overhead by avoiding re-recording commands every frame.
 */
export declare class GpuRenderBundle {
  /** Destroy the render bundle (automatic when dropped) */
  destroy(): void
}
