/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export declare class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
export interface AdapterInfo {
  name: string
  vendor: number
  device: number
  deviceType: string
  backend: string
}
export interface AdapterLimits {
  maxTextureDimension1D: number
  maxTextureDimension2D: number
  maxTextureDimension3D: number
  maxBindGroups: number
  maxBufferSize: number
}
/** Texture descriptor */
export interface TextureDescriptor {
  label?: string
  width: number
  height: number
  depth?: number
  format: string
  usage: number
  dimension?: string
  mipLevelCount?: number
  sampleCount?: number
}
/** Buffer usage flags object */
export interface BufferUsage {
  copySrc: number
  copyDst: number
  storage: number
  uniform: number
  vertex: number
  index: number
  mapRead: number
  mapWrite: number
  indirect: number
  queryResolve: number
}
/** Get buffer usage constants */
export declare function bufferUsage(): BufferUsage
/** Map mode object */
export interface MapMode {
  read: number
  write: number
}
/** Get map mode constants */
export declare function mapMode(): MapMode
/** Texture usage flags object */
export interface TextureUsage {
  copySrc: number
  copyDst: number
  textureBinding: number
  storageBinding: number
  renderAttachment: number
}
/** Get texture usage constants */
export declare function textureUsage(): TextureUsage
/**
 * Bind group entry for buffer resources following WebGPU spec
 * Use this for buffer bindings
 */
export interface BindGroupEntryBuffer {
  binding: number
  buffer: ExternalObject<GpuBuffer>
  offset?: number
  size?: number
}
/** Bind group entry for texture view resources */
export interface BindGroupEntryTexture {
  binding: number
  view: ExternalObject<GpuTextureView>
}
/** Bind group entry for sampler resources */
export interface BindGroupEntrySampler {
  binding: number
  sampler: ExternalObject<GpuSampler>
}
/** Compute pass descriptor (simplified) */
export interface ComputePassDescriptor {
  label?: string
}
/** Render pass descriptor */
export interface RenderPassDescriptor {
  label?: string
  colorAttachments: Array<RenderPassColorAttachment>
  depthStencilAttachment?: RenderPassDepthStencilAttachment
}
export interface RenderPassColorAttachment {
  view: ExternalObject<GpuTextureView>
  resolveTarget?: ExternalObject<GpuTextureView>
  clearValue?: Color
  loadOp: string
  storeOp: string
}
export interface Color {
  r: number
  g: number
  b: number
  a: number
}
export interface RenderPassDepthStencilAttachment {
  view: ExternalObject<GpuTextureView>
  depthClearValue?: number
  depthLoadOp?: string
  depthStoreOp?: string
  stencilClearValue?: number
  stencilLoadOp?: string
  stencilStoreOp?: string
}
/** Sampler descriptor */
export interface SamplerDescriptor {
  label?: string
  addressModeU?: string
  addressModeV?: string
  addressModeW?: string
  magFilter?: string
  minFilter?: string
  mipmapFilter?: string
  lodMinClamp?: number
  lodMaxClamp?: number
  compare?: string
  maxAnisotropy?: number
}
/** Buffer descriptor following WebGPU spec */
export interface BufferDescriptor {
  label?: string
  size: number
  usage: number
  mappedAtCreation?: boolean
}
/** Shader module descriptor following WebGPU spec */
export interface ShaderModuleDescriptor {
  label?: string
  code: string
}
/** Pipeline layout descriptor following WebGPU spec */
export interface PipelineLayoutDescriptor {
  label?: string
  bindGroupLayouts: Array<ExternalObject<GpuBindGroupLayout>>
}
/** Compute pipeline descriptor following WebGPU spec */
export interface ComputePipelineDescriptor {
  label?: string
  layout?: ExternalObject<GpuPipelineLayout>
  compute: ComputeStage
}
export interface ComputeStage {
  module: ExternalObject<GpuShaderModule>
  entryPoint: string
}
/** Command encoder descriptor following WebGPU spec */
export interface CommandEncoderDescriptor {
  label?: string
}
/** Query set descriptor following WebGPU spec */
export interface QuerySetDescriptor {
  label?: string
  type: string
  count: number
}
/** Bind group descriptor following WebGPU spec */
export interface BindGroupDescriptor {
  label?: string
  layout: ExternalObject<GpuBindGroupLayout>
}
/** Bind group layout descriptor following WebGPU spec */
export interface BindGroupLayoutDescriptor {
  label?: string
  entries: Array<BindGroupLayoutEntry>
}
export interface BindGroupLayoutEntry {
  binding: number
  visibility: number
  buffer?: BufferBindingLayout
  sampler?: SamplerBindingLayout
  texture?: TextureBindingLayout
  storageTexture?: StorageTextureBindingLayout
}
export interface BufferBindingLayout {
  type?: string
  hasDynamicOffset?: boolean
  minBindingSize?: number
}
export interface SamplerBindingLayout {
  type?: string
}
export interface TextureBindingLayout {
  sampleType?: string
  viewDimension?: string
  multisampled?: boolean
}
export interface StorageTextureBindingLayout {
  access?: string
  format: string
  viewDimension?: string
}
/** Render pipeline descriptor following WebGPU spec */
export interface RenderPipelineDescriptor {
  label?: string
  layout?: ExternalObject<GpuPipelineLayout>
  vertex: VertexState
  primitive?: PrimitiveState
  depthStencil?: DepthStencilState
  multisample?: MultisampleState
  fragment?: FragmentState
}
export interface VertexState {
  module: ExternalObject<GpuShaderModule>
  entryPoint: string
  buffers?: Array<VertexBufferLayout>
}
export interface VertexBufferLayout {
  arrayStride: number
  stepMode?: string
  attributes: Array<VertexAttribute>
}
export interface VertexAttribute {
  format: string
  offset: number
  shaderLocation: number
}
export interface PrimitiveState {
  topology?: string
  stripIndexFormat?: string
  frontFace?: string
  cullMode?: string
}
export interface DepthStencilState {
  format: string
  depthWriteEnabled?: boolean
  depthCompare?: string
  stencilFront?: StencilFaceState
  stencilBack?: StencilFaceState
  stencilReadMask?: number
  stencilWriteMask?: number
  depthBias?: number
  depthBiasSlopeScale?: number
  depthBiasClamp?: number
}
export interface StencilFaceState {
  compare?: string
  failOp?: string
  depthFailOp?: string
  passOp?: string
}
export interface MultisampleState {
  count?: number
  mask?: number
  alphaToCoverageEnabled?: boolean
}
export interface FragmentState {
  module: ExternalObject<GpuShaderModule>
  entryPoint: string
  targets: Array<ColorTargetState>
}
export interface ColorTargetState {
  format: string
  blend?: BlendState
  writeMask?: number
}
export interface BlendState {
  color: BlendComponent
  alpha: BlendComponent
}
export interface BlendComponent {
  srcFactor: string
  dstFactor: string
  operation: string
}
/** GPU supported limits following WebGPU spec */
export interface GpuSupportedLimits {
  maxTextureDimension1D: number
  maxTextureDimension2D: number
  maxTextureDimension3D: number
  maxTextureArrayLayers: number
  maxBindGroups: number
  maxBindGroupsPlusVertexBuffers: number
  maxBindingsPerBindGroup: number
  maxDynamicUniformBuffersPerPipelineLayout: number
  maxDynamicStorageBuffersPerPipelineLayout: number
  maxSampledTexturesPerShaderStage: number
  maxSamplersPerShaderStage: number
  maxStorageBuffersPerShaderStage: number
  maxStorageTexturesPerShaderStage: number
  maxUniformBuffersPerShaderStage: number
  maxUniformBufferBindingSize: number
  maxStorageBufferBindingSize: number
  minUniformBufferOffsetAlignment: number
  minStorageBufferOffsetAlignment: number
  maxVertexBuffers: number
  maxBufferSize: number
  maxVertexAttributes: number
  maxVertexBufferArrayStride: number
  maxInterStageShaderComponents: number
  maxComputeWorkgroupStorageSize: number
  maxComputeInvocationsPerWorkgroup: number
  maxComputeWorkgroupSizeX: number
  maxComputeWorkgroupSizeY: number
  maxComputeWorkgroupSizeZ: number
  maxComputeWorkgroupsPerDimension: number
}
/**
 * GPU instance - entry point for WebGPU API
 *
 * This is the starting point for all WebGPU operations. Create an instance to
 * enumerate and request GPU adapters.
 */
export declare class Gpu {
  /**
   * Create a new GPU instance
   *
   * Example:
   * ```js
   * const gpu = Gpu.create()
   * ```
   */
  static create(): Gpu
  /**
   * Request a GPU adapter
   *
   * Example:
   * ```js
   * const adapter = await gpu.requestAdapter()
   * ```
   */
  requestAdapter(powerPreference?: string | undefined | null): Promise<GpuAdapter>
  /**
   * Enumerate all available adapters
   *
   * Returns a list of all available GPU adapters with their backend (Metal, Vulkan, DX12).
   * Useful for debugging and displaying available hardware to users.
   */
  enumerateAdapters(): Array<string>
}
/**
 * GPU adapter - represents a physical GPU or software renderer
 *
 * Adapters provide information about GPU capabilities (features, limits)
 * and are used to request logical devices for GPU operations.
 */
export declare class GpuAdapter {
  /**
   * Get adapter information
   *
   * Returns name, vendor ID, device ID, type, and backend.
   */
  getInfo(): AdapterInfo
  /**
   * Get adapter features
   *
   * Returns a list of optional features supported by this adapter.
   * Features must be explicitly requested when creating a device.
   */
  getFeatures(): Array<string>
  /**
   * Get adapter limits
   *
   * Returns maximum resource sizes and counts supported by this adapter.
   */
  getLimits(): AdapterLimits
  /**
   * Request a device from this adapter
   *
   * Creates a logical device for executing GPU operations.
   * Currently requests timestamp query feature by default.
   */
  requestDevice(): Promise<GpuDevice>
}
export declare class GpuDevice {
  /** Get the queue for this device (WebGPU standard property) */
  get queue(): GpuQueue
  /** Get the supported features for this device (WebGPU standard property) */
  get features(): GpuSupportedFeatures
  /** Get the supported limits for this device (WebGPU standard property) */
  get limits(): GpuSupportedLimits
  /** Get the label of this device (WebGPU standard property) */
  get label(): string | null
  /** Create a GPU buffer */
  createBuffer(descriptor: BufferDescriptor): GpuBuffer
  /** Create a shader module */
  createShaderModule(descriptor: ShaderModuleDescriptor): GpuShaderModule
  /** Create a command encoder */
  createCommandEncoder(descriptor?: CommandEncoderDescriptor | undefined | null): GpuCommandEncoder
  /**
   * Submit commands to the queue (deprecated - use device.queue.submit() instead)
   * Note: This consumes the command buffer
   */
  queueSubmit(commandBuffer: GpuCommandBuffer): void
  /** Poll the device */
  poll(forceWait?: boolean | undefined | null): void
  /** Write data to a buffer using the queue (deprecated - use device.queue.writeBuffer() instead) */
  queueWriteBuffer(buffer: GpuBuffer, offset: number, data: Buffer): void
  /** Copy data from one buffer to another (deprecated - use encoder.copyBufferToBuffer() instead) */
  copyBufferToBuffer(encoder: GpuCommandEncoder, source: GpuBuffer, sourceOffset: number, destination: GpuBuffer, destinationOffset: number, size: number): void
  /** Copy data from buffer to texture (deprecated - use encoder.copyBufferToTexture() instead) */
  copyBufferToTexture(encoder: GpuCommandEncoder, source: GpuBuffer, sourceOffset: number, bytesPerRow: number, rowsPerImage: number | undefined | null, destination: GpuTexture, mipLevel: number | undefined | null, originX: number | undefined | null, originY: number | undefined | null, originZ: number | undefined | null, width: number, height: number, depth?: number | undefined | null): void
  /** Copy data from texture to buffer (deprecated - use encoder.copyTextureToBuffer() instead) */
  copyTextureToBuffer(encoder: GpuCommandEncoder, source: GpuTexture, mipLevel: number | undefined | null, originX: number | undefined | null, originY: number | undefined | null, originZ: number | undefined | null, destination: GpuBuffer, destinationOffset: number, bytesPerRow: number, rowsPerImage: number | undefined | null, width: number, height: number, depth?: number | undefined | null): void
  /** Create a texture */
  createTexture(descriptor: TextureDescriptor): GpuTexture
  /** Create a sampler */
  createSampler(descriptor: SamplerDescriptor): GpuSampler
  /** Create a query set for timestamp or occlusion queries */
  createQuerySet(descriptor: QuerySetDescriptor): GpuQuerySet
  /** Create a bind group layout */
  createBindGroupLayout(descriptor: BindGroupLayoutDescriptor): GpuBindGroupLayout
  /** Create a bind group with buffer bindings following WebGPU spec */
  createBindGroup(descriptor: BindGroupDescriptor, bufferEntries: Array<BindGroupEntryBuffer>): GpuBindGroup
  /** Create a bind group with texture bindings */
  createBindGroupTextures(descriptor: BindGroupDescriptor, textureEntries: Array<BindGroupEntryTexture>): GpuBindGroup
  /** Create a bind group with sampler bindings */
  createBindGroupSamplers(descriptor: BindGroupDescriptor, samplerEntries: Array<BindGroupEntrySampler>): GpuBindGroup
  /** Create a pipeline layout */
  createPipelineLayout(descriptor: PipelineLayoutDescriptor): GpuPipelineLayout
  /** Create a compute pipeline following WebGPU spec */
  createComputePipeline(descriptor: ComputePipelineDescriptor): GpuComputePipeline
  /** Create a render pipeline following WebGPU spec */
  createRenderPipeline(descriptor: RenderPipelineDescriptor): GpuRenderPipeline
  /**
   * Create a render bundle - reusable recorded render commands
   * This creates a bundle that can be executed multiple times in render passes
   */
  createRenderBundle(label: string, pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, vertexCount: number, bindGroups: Array<GpuBindGroup> | undefined | null, colorFormats: Array<string>): GpuRenderBundle
  /** Create an indexed render bundle */
  createRenderBundleIndexed(label: string, pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, indexBuffer: GpuBuffer, indexFormat: string, indexCount: number, bindGroups: Array<GpuBindGroup> | undefined | null, colorFormats: Array<string>): GpuRenderBundle
  /** Destroy the device */
  destroy(): void
}
export declare class GpuShaderModule { }
export declare class GpuCommandEncoder {
  /** Begin a compute pass and execute it with the given pipeline and bind groups */
  computePass(pipeline: GpuComputePipeline, bindGroups: Array<GpuBindGroup>, workgroupsX: number, workgroupsY?: number | undefined | null, workgroupsZ?: number | undefined | null): void
  /**
   * Execute a compute pass with indirect dispatch
   * The indirect buffer contains dispatch parameters (workgroups_x, workgroups_y, workgroups_z)
   */
  computePassIndirect(pipeline: GpuComputePipeline, bindGroups: Array<GpuBindGroup>, indirectBuffer: GpuBuffer, indirectOffset: number): void
  /**
   * Execute a render pass (simplified inline execution)
   * color_attachments: array of texture views to render to (MSAA textures if using MSAA)
   * clear_colors: optional array of [r, g, b, a] values for clearing
   * bind_groups: optional array of bind groups to set
   * depth_stencil_attachment: optional depth/stencil texture view
   * clear_depth: optional depth clear value (0.0 to 1.0)
   * resolve_targets: optional array of texture views to resolve MSAA to (must match color_attachments length)
   */
  renderPass(pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, vertexCount: number, colorAttachments: Array<GpuTextureView>, clearColors?: Array<Array<number>> | undefined | null, bindGroups?: Array<GpuBindGroup> | undefined | null, depthStencilAttachment?: GpuTextureView | undefined | null, clearDepth?: number | undefined | null, resolveTargets?: Array<GpuTextureView> | undefined | null): void
  /** Execute a render pass with indexed drawing */
  renderPassIndexed(pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, indexBuffer: GpuBuffer, indexFormat: string, indexCount: number, colorAttachments: Array<GpuTextureView>, clearColors?: Array<Array<number>> | undefined | null, bindGroups?: Array<GpuBindGroup> | undefined | null, depthStencilAttachment?: GpuTextureView | undefined | null, clearDepth?: number | undefined | null, resolveTargets?: Array<GpuTextureView> | undefined | null): void
  /**
   * Execute a render pass with indirect drawing
   * The indirect buffer contains draw parameters (vertex_count, instance_count, first_vertex, first_instance)
   */
  renderPassIndirect(pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, indirectBuffer: GpuBuffer, indirectOffset: number, colorAttachments: Array<GpuTextureView>, clearColors?: Array<Array<number>> | undefined | null, bindGroups?: Array<GpuBindGroup> | undefined | null, depthStencilAttachment?: GpuTextureView | undefined | null, clearDepth?: number | undefined | null, resolveTargets?: Array<GpuTextureView> | undefined | null): void
  /**
   * Execute a render pass with indexed indirect drawing
   * The indirect buffer contains draw parameters (index_count, instance_count, first_index, base_vertex, first_instance)
   */
  renderPassIndexedIndirect(pipeline: GpuRenderPipeline, vertexBuffers: Array<GpuBuffer>, indexBuffer: GpuBuffer, indexFormat: string, indirectBuffer: GpuBuffer, indirectOffset: number, colorAttachments: Array<GpuTextureView>, clearColors?: Array<Array<number>> | undefined | null, bindGroups?: Array<GpuBindGroup> | undefined | null, depthStencilAttachment?: GpuTextureView | undefined | null, clearDepth?: number | undefined | null, resolveTargets?: Array<GpuTextureView> | undefined | null): void
  /**
   * Write a timestamp to a query set
   * query_set: the query set to write to
   * query_index: the index of the query to write (0 to count-1)
   */
  writeTimestamp(querySet: GpuQuerySet, queryIndex: number): void
  /**
   * Resolve query results to a buffer
   * query_set: the query set to resolve
   * first_query: the first query index to resolve
   * query_count: the number of queries to resolve
   * destination: the buffer to write results to
   * destination_offset: the byte offset in the destination buffer
   */
  resolveQuerySet(querySet: GpuQuerySet, firstQuery: number, queryCount: number, destination: GpuBuffer, destinationOffset: number): void
  /**
   * Execute render bundles in a render pass
   * This is more efficient than recording the same commands multiple times
   */
  renderPassBundles(bundles: Array<GpuRenderBundle>, colorAttachments: Array<GpuTextureView>, clearColors?: Array<Array<number>> | undefined | null): void
  /** Copy data from one buffer to another (WebGPU standard method) */
  copyBufferToBuffer(source: GpuBuffer, sourceOffset: number, destination: GpuBuffer, destinationOffset: number, size: number): void
  /** Copy data from buffer to texture (WebGPU standard method) */
  copyBufferToTexture(source: GpuBuffer, sourceOffset: number, bytesPerRow: number, rowsPerImage: number | undefined | null, destination: GpuTexture, mipLevel: number | undefined | null, originX: number | undefined | null, originY: number | undefined | null, originZ: number | undefined | null, width: number, height: number, depth?: number | undefined | null): void
  /** Copy data from texture to buffer (WebGPU standard method) */
  copyTextureToBuffer(source: GpuTexture, mipLevel: number | undefined | null, originX: number | undefined | null, originY: number | undefined | null, originZ: number | undefined | null, destination: GpuBuffer, destinationOffset: number, bytesPerRow: number, rowsPerImage: number | undefined | null, width: number, height: number, depth?: number | undefined | null): void
  /** Finish encoding and return a command buffer */
  finish(): GpuCommandBuffer
}
export declare class GpuCommandBuffer { }
/**
 * GPU buffer - contiguous memory allocation on the GPU
 *
 * Buffers store data for shaders (vertices, indices, uniforms, storage).
 * They can be written from CPU (via queueWriteBuffer) and read back (via mapRead).
 */
export declare class GpuBuffer {
  /** Get the size of the buffer */
  size(): number
  /** Get the usage flags of the buffer */
  usage(): number
  /**
   * Map the buffer asynchronously for reading or writing
   *
   * Asynchronously maps the buffer for CPU access.
   * mode: "READ" or "WRITE"
   * Buffer must have MAP_READ or MAP_WRITE usage flag.
   */
  mapAsync(mode: string): Promise<void>
  /**
   * Get the mapped range as a buffer
   *
   * Returns the mapped data as a Node.js Buffer.
   * Must be called after mapAsync() succeeds.
   * The buffer must remain mapped until unmap() is called.
   */
  getMappedRange(): Buffer
  /**
   * Unmap the buffer
   *
   * Releases the mapped memory. Must be called after mapRead before using buffer in GPU operations.
   */
  unmap(): void
  /** Write data to buffer using mapped memory */
  writeBuffer(data: Buffer): Promise<void>
  /**
   * Destroy the buffer
   *
   * Explicitly releases GPU resources. Buffers are automatically destroyed when dropped.
   */
  destroy(): void
}
/**
 * GPU texture - multi-dimensional image data on the GPU
 *
 * Textures store image data for rendering and compute operations.
 * Create views to bind textures to shaders.
 */
export declare class GpuTexture {
  /** Create a view of this texture */
  createView(label?: string | undefined | null): GpuTextureView
  /** Get texture width */
  width(): number
  /** Get texture height */
  height(): number
  /** Destroy the texture */
  destroy(): void
}
/**
 * Texture view - a view into a texture for binding to shaders
 *
 * Views define how shaders access texture data (format, mip levels, array layers).
 */
export declare class GpuTextureView { }
/**
 * Bind group layout - describes resource bindings for shaders
 *
 * Bind group layouts define the structure of bind groups: which binding indices
 * contain buffers, textures, or samplers, and their visibility (vertex/fragment/compute).
 */
export declare class GpuBindGroupLayout { }
/**
 * Bind group - collection of resources bound to shaders
 *
 * Bind groups connect GPU resources (buffers, textures, samplers) to shader binding points.
 * They're bound to pipelines during command encoding.
 */
export declare class GpuBindGroup { }
/**
 * Pipeline layout - defines bind group layouts for a pipeline
 *
 * Pipeline layouts specify the organization of bind groups (resources like buffers, textures)
 * that shaders can access during pipeline execution.
 */
export declare class GpuPipelineLayout { }
/**
 * Compute pipeline - configured compute shader program
 *
 * Compute pipelines execute compute shaders for general-purpose GPU computation.
 * They're created from a shader module, entry point, and pipeline layout.
 */
export declare class GpuComputePipeline { }
/**
 * Render pipeline - configured graphics pipeline
 *
 * Render pipelines define the complete graphics state: vertex/fragment shaders,
 * vertex layout, blend modes, depth/stencil, and MSAA configuration.
 */
export declare class GpuRenderPipeline { }
/**
 * GPU sampler - defines how textures are sampled in shaders
 *
 * Samplers control filtering (nearest/linear), address modes (repeat/clamp),
 * and LOD (level of detail) for texture sampling.
 */
export declare class GpuSampler { }
/**
 * GPU query set - for GPU performance measurement
 *
 * Query sets collect GPU timestamps for profiling render and compute passes.
 */
export declare class GpuQuerySet {
  /** Destroy the query set */
  destroy(): void
}
/**
 * Render bundle - pre-recorded render commands that can be reused
 *
 * Render bundles record draw commands once and execute them multiple times.
 * This reduces CPU overhead by avoiding re-recording commands every frame.
 */
export declare class GpuRenderBundle {
  /** Destroy the render bundle (automatic when dropped) */
  destroy(): void
}
/** GPU queue for submitting commands following WebGPU spec */
export declare class GpuQueue {
  /** Submit command buffers to the queue */
  submit(commandBuffer: GpuCommandBuffer): void
  /** Write data to a buffer using the queue */
  writeBuffer(buffer: GpuBuffer, offset: number, data: Buffer): void
  /** Get the label of this queue */
  get label(): string | null
}
/** GPU supported features following WebGPU spec */
export declare class GpuSupportedFeatures {
  /** Check if a feature is supported */
  has(feature: string): boolean
  /** Get the number of features supported */
  get size(): number
}
